# Story 1.7: Document Viewer & Editor

## Status

Draft

## Story

**As a** user,
**I want** to view and edit Markdown documents,
**so that** I can read and contribute to the knowledge base.

## Acceptance Criteria

1. Document view page renders Markdown content with proper formatting
2. Code blocks display with syntax highlighting
3. Metadata bar shows: Created by, Modified by, Last updated (relative time)
4. Edit button (visible to document owner) navigates to editor
5. Editor page has split view: Markdown textarea (left), live preview (right)
6. Save button submits changes and redirects to view page
7. Cancel button discards changes and returns to view
8. Create new document: "New Document" button in folder view opens editor
9. New documents require title; content can be empty
10. Unsaved changes prompt confirmation before navigation

## Tasks / Subtasks

- [ ] **Task 1: Extend document API service** (AC: 1, 4, 6, 8)

  - [ ] Ensure `apps/web/lib/api/services/documents.ts` exists (from Story 1.6)
  - [ ] Verify `getDocument(id: string): Promise<DocumentWithMeta>` implemented
  - [ ] Implement `createDocument(data: CreateDocumentInput): Promise<Document>`
  - [ ] Implement `updateDocument(id: string, data: UpdateDocumentInput): Promise<Document>`
  - [ ] Export service from barrel file

- [ ] **Task 2: Update document page with API integration** (AC: 1, 2, 3, 4)

  - [ ] Update `apps/web/app/document/page.tsx`
  - [ ] Get `id` from URL search params (`?id={documentId}`)
  - [ ] Fetch document using `documentService.getDocument(id)`
  - [ ] Pass document data to DocumentViewPage component
  - [ ] Handle loading state with skeleton
  - [ ] Handle error state (document not found)

- [ ] **Task 3: Update DocumentViewPage component** (AC: 1, 2, 3, 4)

  - [ ] Update `apps/web/components/document/DocumentViewPage.tsx`
  - [ ] Remove hardcoded mock data
  - [ ] Accept `document: DocumentWithMeta` as prop
  - [ ] Wire Edit button to navigate to `/editor?id={documentId}`
  - [ ] Show Edit button only if current user is document owner (compare user.id)
  - [ ] Update breadcrumbs to use document's `folderPath`

- [ ] **Task 4: Update MetadataBar component** (AC: 3)

  - [ ] Update `apps/web/components/document/MetadataBar.tsx`
  - [ ] Change interface to accept `PublicUser` type from `@simpleconf/shared`:
    - `createdBy: PublicUser`
    - `modifiedBy: PublicUser | null`
  - [ ] Generate avatar initials from `displayName`
  - [ ] Format `updatedAt` using relative time helper

- [ ] **Task 5: Update editor page with API integration** (AC: 5, 6, 7, 8, 9)

  - [ ] Update `apps/web/app/editor/page.tsx`
  - [ ] Get `id` (edit mode) or `folderId` (create mode) from URL search params
  - [ ] If `id` provided: fetch existing document for editing
  - [ ] If `folderId` provided: create new document mode
  - [ ] Pass mode and data to DocumentEditorPage component

- [ ] **Task 6: Update DocumentEditorPage for edit mode** (AC: 4, 5, 6, 7)

  - [ ] Update `apps/web/components/editor/DocumentEditorPage.tsx`
  - [ ] Accept props: `mode: 'edit' | 'create'`, `document?: DocumentWithMeta`, `folderId?: string`
  - [ ] Remove hardcoded mock data
  - [ ] Initialize title/content from document prop (edit) or empty (create)
  - [ ] Update Save button to call `documentService.updateDocument()` for edit mode
  - [ ] On successful save, navigate to `/document?id={documentId}`
  - [ ] Update Cancel button to navigate back to document (edit) or folder (create)

- [ ] **Task 7: Update DocumentEditorPage for create mode** (AC: 8, 9)

  - [ ] Handle create mode when no document ID provided
  - [ ] Require folderId in create mode
  - [ ] Save button calls `documentService.createDocument({ title, content, folderId })`
  - [ ] Validate title is not empty before enabling Save
  - [ ] On successful create, navigate to `/document?id={newDocumentId}`
  - [ ] Cancel navigates back to `/folder?id={folderId}`

- [ ] **Task 8: Implement unsaved changes navigation guard** (AC: 10)

  - [ ] Verify `beforeunload` handler already works (exists in DocumentEditorPage)
  - [ ] Integrate with Next.js App Router navigation
  - [ ] Use `useRouter` events or custom hook to intercept client-side navigation
  - [ ] Show UnsavedChangesDialog before navigating away with unsaved changes

- [ ] **Task 9: Wire "New Document" button in folder page** (AC: 8)

  - [ ] Update `apps/web/app/folder/page.tsx`
  - [ ] Wire "New Document" button to navigate to `/editor?folderId={currentFolderId}`
  - [ ] Ensure button only visible when user has write access to folder

- [ ] **Task 10: Verify Markdown rendering features** (AC: 1, 2)

  - [ ] Verify MarkdownRenderer properly formats all Markdown elements
  - [ ] Verify code blocks have syntax highlighting (dark theme)
  - [ ] Verify tables render correctly
  - [ ] Verify links are clickable
  - [ ] Verify headings have anchor links

## Dev Notes

### Critical Dependencies

**Story 1.4 (Folder & Document CRUD API):** Backend document endpoints must be implemented:
- `GET /api/documents/:id` - returns DocumentWithMeta
- `POST /api/documents` - creates new document
- `PUT /api/documents/:id` - updates document (owner only)

**Story 1.6 (Folder Tree Navigation):** Document API service should be created there.

### Previous Story Insights

[Source: docs/stories/1.5.story.md, docs/stories/1.6.story.md]

**From Story 1.5 - Auth Context:**

- `useAuth()` hook provides `user` object with current user's `id`
- Use `user.id === document.createdBy` to check ownership for Edit button visibility

**From Story 1.6 - Document Service Pattern:**

```typescript
// apps/web/lib/api/services/documents.ts
import { apiClient } from "../client";
import type {
  DocumentWithMeta,
  CreateDocumentInput,
  UpdateDocumentInput,
} from "@simpleconf/shared";

export const documentService = {
  async getDocument(id: string): Promise<{ document: DocumentWithMeta }> {
    return apiClient<{ document: DocumentWithMeta }>(`/documents/${id}`);
  },

  async createDocument(data: CreateDocumentInput): Promise<{ document: Document }> {
    return apiClient<{ document: Document }>("/documents", {
      method: "POST",
      body: JSON.stringify(data),
    });
  },

  async updateDocument(id: string, data: UpdateDocumentInput): Promise<{ document: Document }> {
    return apiClient<{ document: Document }>(`/documents/${id}`, {
      method: "PUT",
      body: JSON.stringify(data),
    });
  },
};
```

### API Endpoints

[Source: architecture/api-specification.md#Document Endpoints]

| Method | Endpoint         | Purpose                             | Auth Required |
| ------ | ---------------- | ----------------------------------- | ------------- |
| GET    | `/documents/:id` | Get full document (increments view) | Yes           |
| POST   | `/documents`     | Create new document                 | Yes           |
| PUT    | `/documents/:id` | Update document                     | Yes (owner)   |

```typescript
// GET /documents/:id
interface DocumentResponse {
  document: DocumentWithMeta;
}

// POST /documents
interface CreateDocumentRequest {
  title: string;
  content: string;
  folderId: string;
}

// PUT /documents/:id
interface UpdateDocumentRequest {
  title?: string;
  content?: string;
}
```

### Data Models

[Source: architecture/data-models.md]

**DocumentWithMeta:**

```typescript
interface DocumentWithMeta extends Document {
  commentCount: number;
  createdByUser: PublicUser;
  modifiedByUser: PublicUser | null;
  folderPath: string;
}

interface Document {
  id: string;
  title: string;
  content: string;
  folderId: string;
  createdBy: string;
  modifiedBy: string | null;
  viewCount: number;
  createdAt: Date;
  updatedAt: Date;
}
```

**PublicUser:**

```typescript
type PublicUser = Pick<User, "id" | "displayName" | "department">;

// For avatar initials:
function getInitials(displayName: string): string {
  return displayName
    .split(" ")
    .map((n) => n[0])
    .join("")
    .toUpperCase()
    .slice(0, 2);
}
```

### Existing Components (Current State)

[Source: apps/web/components/document/, apps/web/components/editor/]

| Component | Status | Updates Needed |
|-----------|--------|----------------|
| `DocumentViewPage.tsx` | Mock data | Wire to API, accept document prop |
| `MarkdownRenderer.tsx` | Functional | None - already has syntax highlighting |
| `MetadataBar.tsx` | Mock types | Use PublicUser, format dates |
| `DocumentEditorPage.tsx` | Mock data | Wire to API, add create/edit modes |
| `MarkdownEditor.tsx` | Functional | None |
| `EditorPreview.tsx` | Functional | None |
| `EditorToolbar.tsx` | Functional | None |
| `UnsavedChangesDialog.tsx` | Functional | None |

**MarkdownRenderer Features Already Implemented:**
- Code block syntax highlighting (dark slate-900 theme)
- Copy-to-clipboard for code blocks
- Anchor links on headings (h1, h2, h3)
- Styled tables with zebra striping
- Inline code styling

**DocumentEditorPage Features Already Implemented:**
- Split view with resizable panes (20%-80% constraints)
- Title input field
- Ctrl/Cmd+S keyboard shortcut for save
- beforeunload handler for unsaved changes
- UnsavedChangesDialog integration
- Toolbar with Bold, Italic, Code, Link, Heading buttons

### Navigation Patterns

[Source: Next.js App Router conventions]

**URL Structure:**

- View document: `/document?id={documentId}`
- Edit document: `/editor?id={documentId}`
- Create document: `/editor?folderId={folderId}`

**Navigation Code:**

```typescript
import { useRouter, useSearchParams } from "next/navigation";

const router = useRouter();
const searchParams = useSearchParams();

// Get params
const documentId = searchParams.get("id");
const folderId = searchParams.get("folderId");

// Navigate after save
router.push(`/document?id=${savedDocument.id}`);

// Navigate on cancel (edit mode)
router.push(`/document?id=${documentId}`);

// Navigate on cancel (create mode)
router.push(`/folder?id=${folderId}`);
```

**App Router Navigation Guard:**

Next.js App Router doesn't have built-in navigation guards like vue-router. Use this pattern:

```typescript
// Custom hook for navigation guard
import { useEffect } from "react";
import { useRouter } from "next/navigation";

export function useNavigationGuard(hasUnsavedChanges: boolean) {
  const router = useRouter();

  useEffect(() => {
    // Browser navigation (back/forward/close)
    const handleBeforeUnload = (e: BeforeUnloadEvent) => {
      if (hasUnsavedChanges) {
        e.preventDefault();
        e.returnValue = "";
      }
    };

    window.addEventListener("beforeunload", handleBeforeUnload);
    return () => window.removeEventListener("beforeunload", handleBeforeUnload);
  }, [hasUnsavedChanges]);

  // For programmatic navigation, check hasUnsavedChanges before calling router.push()
}
```

### Relative Time Formatting

[Source: docs/stories/1.6.story.md]

```typescript
function formatRelativeTime(date: Date | string): string {
  const now = new Date();
  const then = new Date(date);
  const diffMs = now.getTime() - then.getTime();
  const diffMins = Math.floor(diffMs / (1000 * 60));
  const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
  const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

  if (diffMins < 1) return "Just now";
  if (diffMins < 60) return `${diffMins} minutes ago`;
  if (diffHours < 24) return `${diffHours} hours ago`;
  if (diffDays === 1) return "Yesterday";
  if (diffDays < 7) return `${diffDays} days ago`;
  if (diffDays < 30) return `${Math.floor(diffDays / 7)} weeks ago`;
  return then.toLocaleDateString();
}
```

### File Locations

[Source: architecture/project-structure.md]

```
apps/web/
├── app/
│   ├── document/page.tsx          # UPDATE: API integration, URL params
│   ├── editor/page.tsx            # UPDATE: API integration, create/edit modes
│   └── folder/page.tsx            # UPDATE: Wire New Document button
├── components/
│   ├── document/
│   │   ├── DocumentViewPage.tsx   # UPDATE: Accept props, wire Edit button
│   │   ├── MetadataBar.tsx        # UPDATE: Use PublicUser type
│   │   ├── MarkdownRenderer.tsx   # NO CHANGES - already functional
│   │   └── CommentsSection.tsx    # NO CHANGES for this story
│   └── editor/
│       ├── DocumentEditorPage.tsx # UPDATE: API integration, modes
│       ├── MarkdownEditor.tsx     # NO CHANGES - already functional
│       ├── EditorPreview.tsx      # NO CHANGES - already functional
│       ├── EditorToolbar.tsx      # NO CHANGES - already functional
│       └── UnsavedChangesDialog.tsx # NO CHANGES - already functional
├── lib/
│   ├── api/
│   │   └── services/
│   │       └── documents.ts       # UPDATE: Add create/update methods
│   └── utils/
│       └── format.ts              # NEW (optional): Relative time formatter
```

### Coding Standards

[Source: architecture/coding-standards.md]

| Rule         | Application                             |
| ------------ | --------------------------------------- |
| Components   | PascalCase (`DocumentViewPage.tsx`)     |
| API Calls    | Use service layer, never fetch directly |
| Type Sharing | Import from `@simpleconf/shared`        |
| State        | React useState for local state          |

### Testing

[Source: architecture/testing-strategy.md]

**Test Location:** `apps/web/__tests__/`

**Testing Framework:** Vitest + React Testing Library

**Key Test Scenarios:**

- DocumentViewPage renders document content correctly
- DocumentViewPage shows Edit button only for owner
- MarkdownRenderer displays code blocks with syntax highlighting
- MetadataBar formats dates as relative time
- DocumentEditorPage saves document on Save button click
- DocumentEditorPage shows unsaved changes dialog on Cancel with changes
- DocumentEditorPage requires title before enabling Save
- New document creation works with folderId

## Change Log

| Date       | Version | Description           | Author         |
| ---------- | ------- | --------------------- | -------------- |
| 2025-12-23 | 0.1     | Initial draft created | Bob (SM Agent) |

---

## Dev Agent Record

### Agent Model Used

<!-- To be filled by dev agent -->

### Debug Log References

<!-- To be filled by dev agent -->

### Completion Notes List

<!-- To be filled by dev agent -->

### File List

<!-- To be filled by dev agent -->

---

## QA Results

<!-- To be filled by QA agent -->
